# Chapter7

## 7.1.4
类类型变量在定义时没有显式初始化，则会调用默认构造函数。如果没有默认构造函数，则定义该类型对象时必须提供显式初始化。

编译器生成的默认构造函数会按照如下规则初始化成员：
- 如果有提供类内初始值，用它来初始化成员。
- 否则，[默认初始化](/Chapter2/README.md/#221)该成员。

某些类不能依赖合成的默认构造函数。
- 只有当类没有声明任何构造函数时，才会自动生成合成的默认构造函数。
- 如果类内包含内置类型或者复合类型时，则只有当这些成员被赋予了类内初始值，这个类才适合于合成的构造函数。
- 如果类中包含其他类类型且这个类类型没有合成的默认构造函数，则编译器无法初始化该成员。

```C++
class A
{
public:
	
	int f1;
};

A a;

int main()
{
	A b;
	cout << a.f1 << endl;
	cout << b.f1 << endl; //默认初始化在块作用域内定义，未定义行为。
}
```

## 7.5.3
### 当对象被默认初始化或值初始化时自动执行默认构造函数：
值初始化：
- 在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；
```C++
{
	int[5] a = {1,2,3}; //a {1,2,3,0,0}
}
```
- 当我们不使用初始值定义一个局部静态对象时；
```C++
{
	static int a ; // a = 0
}
```
- 当我们通过书写形如T()的表达式（例如 int()）显式地请求值初始化时；
```C++
{
	int* a = int();// a = 0
}
```

 
默认初始化：
- 当我们在块作用域内不使用任何初始值定义一个非静态变量时； 
```C++
{
	int a; // a undefined behavior
}
```
- 当一个类本身含有类类型成员且使用合成的默认构造函数时；
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时；

explicit 只能用于直接初始化
一个const成员函数如果以引用的形式返回*this，那么一定是常量引用
```C++
class Test
{
public:
    int a = 1;
    Test() {}
    const Test& operator()() const
    {
        return *this;
    }
    explicit Test(const Test& test)
    {
        this -> a = test.a;
    }
};
```